# Asynchronous tests

## Introduction

With Jest, we can test asynchronous code in multiple ways. The following cases uses `async` / `await`. Some main differences from traditional tests:

- The Jest global `it()` callback must be `async` so that we can use `await` inside.
- It's recommended to use `expect.assertion(number)` to tell Jest how many assertions are expected before finishing:

```js
// Success async call
it('should wake up eventually', async () => {
  expect.assertions(1)
  const result = await wakeUpAt(10)
  expect(result).toEqual('awake at 10:00!')
})

// Failed async call
it('should not wake up too early', async () => {
  expect.assertions(1)
  await expect(wakeUpAt(6)).rejects.toEqual({
    error: '6:00 is too earlier!',
  })
})
```

We can also mock async functions result using [`jest.fn().mockResolvedValue()`](https://jestjs.io/docs/en/mock-function-api#mockfnmockresolvedvaluevalue).

```js
it('should wake up eventually', async () => {
  const asyncEventMock = jest.fn().mockResolvedValue('success')

  const result = await asyncEventMock()

  expect(result).toBe('success')
})
```

## Dealing with HTTP Requests

The [Fetch API](https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API/Using_Fetch) is a browser feature. Jest tests are run in Node enviroment. That means that tests will break when crossed with `fetch` because it does not exist in Node.

To solve that problem we need to mock `fetch`, which isn't an easy task. Luckly for us, there's [`jest-fetch-mock`](https://github.com/jefflau/jest-fetch-mock) package that does that for us! (You can see that package as a _fake_ - a simplified version of fetch).

```js
import fetchMock from 'jest-fetch-mock'

beforeAll(() => {
  // This creates the mocks so that it can be asserted later
  fetchMock.enableMocks()
})

it('getRandomAnimal() returns a random fact', async () => {
  const fact = {
    fact: 'The average litter of kittens is between 2 - 6 kittens.',
    length: 55,
  }

  global.fetch.mockResponse(JSON.stringify(fact))

  const result = await getRandomAnimal()

  // Assert the fetch was called with the right URL
  expect(global.fetch).toHaveBeenCalledTimes(1)
  expect(global.fetch).toHaveBeenCalledWith('https://catfact.ninja/fact', {
    method: 'GET',
  })

  expect(result).toEqual(fact)
})
```

## Exercise

In the file `Bored.test.js`,
will test the `BoredAPI.js`. This module is a _real world_ module. It means that it deals with a real API that does HTTP requests to [The Bored API](https://www.boredapi.com/) using `fetch`.

Your goal is to complete the tests marked with `it.todo()`

<!-- TODO prepare exercise! -->

## Bonus

### #1 Mock Service Worker

A alternative to `jest-fetch-mock` is [msw](https://github.com/mswjs/msw), which is a step further when mocking requests.

There are some differences:

- The `fetch` is not mocked. Instead it creates a server to intercept the requests.
- It supports both `REST` and `GraphQL`.
- The mocks created can live alongside the rest of the app. It can be used for development, unit testing and E2E testing!

That sound promissing, uh?

The setup and most of some of the tests using `msw` are already done for you.

Your goal here is just to read directly `boredAPI-msw.solution.test.js` and get to know how is it done. There are still a few `it.todo()` left to be done. You can do them!

If this rings a bell to you, I highly recommend you to read [Stop Mocking fetch](https://kentcdodds.com/blog/stop-mocking-fetch).

## References

- [Jest - Async tutorial](https://jestjs.io/docs/en/tutorial-async)
- <!-- TODO VERIFY THIS -->
  <!--


- ESLINT reset config to workshop
- Missing eslint endofline

---

- **Mock:** Replace the original behavior of a function with another version.

- **Spy:** Similar to a mock, but it keeps the original behavior.

- **Fake:** A simplified and controlled version of a function. To be used as a mock implementation. A fake can return stubs in itself.

- **Stub:** A stub is an object with realistic data. Usually used as result of a mocked function, to test a specific scenario.

```js
// Using "foo bar" makes it hard for new developers
// to understand realistically what type of data is expected
getActivity.mockReturnValue({
  activity: 'Foo',
  type: 'something',
  participants: 2,
  price: 0,
  key: 123,
})

// With stubs it's way to realistic
const activityStubs = {
  pricePaid: {
    activity: 'Play a game of tennis with a friend',
    type: 'social',
    participants: 2,
    price: 0.1,
    accessibility: 'Major challenges',
    link: '',
    key: '1093640',
  },
}

getActivity.mockReturnValue(activityStubs.with2people)
```

-->
